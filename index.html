<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <title>Изометрический город</title>
    <style>
        html,
        body {
            position: relative;
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #eef;
        }

        #city-holder {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #city {
            position: absolute;
            width: 5000px;
            height: 5000px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #city-buildings {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        #grid-container {
            position: absolute;
            width: 1000px;
            height: 1000px;
            transform-origin: 0 0;
            transform: rotateX(60deg) rotateZ(-45deg) scale(0.7) translate(-50%, -50%);
            perspective: 1000px;
            top: 50%;
            left: 50%;
        }

        .building {
            position: absolute;
            background-size: cover;
            background-repeat: no-repeat;
            transform: translate(-50%, -100%);
            pointer-events: auto;
            user-select: none;

        }

        .building.dragging {
            opacity: 0.8;
            cursor: grabbing;
        }



        .grid {
            position: absolute;
            width: 5000px;
            height: 5000px;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.3) 1px, transparent 1px);
            background-size: 100px 100px;
            transform: translate(-50%, -50%);
        }
    </style>
</head>

<body>
    <div id="city-holder">

        <div id="city">
            <div id="city-buildings"></div>
            <div id="grid-container">
                <div class="grid" style="left: 50%; top: 50%;"></div>
            </div>
        </div>
    </div>
    <script>
        const cityHolder = document.getElementById("city-holder");
        const cityContainer = document.getElementById("city");
        const cityBuildings = document.getElementById("city-buildings");
        const tileWidth = 99;
        const tileHeight = 49.5;
        const maxScale = 1;
        const minScale = 0.1;
        const scaleStep = 0.1;
        let isDragging = false;
        let isPanning = false;
        let scale = 1;
        let worldX = 0;
        let worldY = 0;
        const cityRect = cityContainer.getBoundingClientRect();
        const buildings = [
            // { id: 5, x: 3, y: 2, w: 1, h: 1, image: 'img/obj_cit_001_06.png' },
            // { id: 6, x: 2, y: 4, w: 1, h: 1, image: 'img/obj_cit_004_06.png' },
            // { id: 7, x: 5, y: 1, w: 2, h: 2, image: 'img/obj_cit_007_07.png' },


            { id: 1, x: 0, y: 0, w: 2, h: 2, image: 'img/obj_cit_004_06.png' },
            { id: 2, x: -5, y: -5, w: 1, h: 1, image: 'img/obj_cit_004_06.png' },
            { id: 3, x: 5, y: 5, w: 1, h: 1, image: 'img/obj_cit_004_06.png' },
            { id: 4, x: 8, y: -2, w: 5, h: 5, image: 'img/obj_cit_004_06.png' },

        ];

        function gridToScreen(x, y) {
            return {
                left: (x - y) * (tileWidth / 2) + cityRect.width / 2,
                top: (x + y) * (tileHeight / 2) + cityRect.height / 2,
            };
        }

        function screenToGrid(left, top) {
            const centerX = left - cityRect.width / 2;
            const centerY = top - cityRect.height / 2;
            const x = (centerY / (tileHeight / 2) + centerX / (tileWidth / 2)) / 2;
            const y = (centerY / (tileHeight / 2) - centerX / (tileWidth / 2)) / 2;
            return {
                x: Math.round(x),
                y: Math.round(y)
            };
        }

        function renderBuildings() {
            cityBuildings.innerHTML = "";
            buildings
                .forEach(b => {
                    const { left, top } = gridToScreen(b.x, b.y);
                    const { left: centerLeft, top: centerTop } = gridToScreen(b.x + (b.w - 1) / 2, b.y + (b.h - 1) / 2);
                    const div = document.createElement("div");
                    div.className = "building";
                    div.style.backgroundImage = `url(${b.image})`;
                    div.style.width = `${tileWidth * b.w}px`;
                    div.style.height = `${tileWidth * b.h}px`;
                    div.style.transform = `translate(${left}px, ${top + tileHeight * (b.h - 1)}px) translate(-50%, -100%)`;
                    div.style.zIndex = Math.round(100000 + centerTop);
                    div.dataset.id = b.id;
                    addDragListeners(div);
                    cityBuildings.appendChild(div);
                });
        }

        function updateTransform() {
            cityContainer.style.transform = `translate(${-50 + worldX * 100}%, ${-50 + worldY * 100}%) scale(${scale}, ${scale})`
        }

        function isOccupied(x, y, w, h, excludeId = null) {
            return buildings.some(b => {
                if (b.id === excludeId) return false;
                return !(
                    x + w <= b.x ||
                    x >= b.x + b.w ||
                    y + h <= b.y ||
                    y >= b.y + b.h
                );
            });
        }

        function addDragListeners(el) {
            let startX, startY;
            let offsetX, offsetY;
            let building = buildings.find(b => b.id == el.dataset.id);

            el.addEventListener("pointerdown", e => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                const { left, top } = gridToScreen(building.x, building.y);
                offsetX = left;
                offsetY = top;
                el.classList.add("dragging");
                el.style.zIndex = "9999999";
                el.setPointerCapture(e.pointerId);
            });

            el.addEventListener("pointermove", e => {
                if (!isDragging) return;
                const dx = (e.clientX - startX) / scale;
                const dy = (e.clientY - startY) / scale;
                el.style.transform = `translate(${offsetX + dx}px, ${offsetY + dy + tileHeight * (building.h - 1)}px) translate(-50%, -100%)`;
            });

            el.addEventListener("pointerup", e => {
                if (!isDragging) return;
                isDragging = false;
                const finalX = offsetX + (e.clientX - startX) / scale;
                const finalY = offsetY + (e.clientY - startY) / scale;
                const { x, y } = screenToGrid(finalX, finalY);

                const collision = isOccupied(x, y, building.w, building.h, building.id);

                if (!collision) {
                    building.x = x;
                    building.y = y;
                }

                el.classList.remove("dragging");
                renderBuildings();
            });
        }

        cityHolder.addEventListener("wheel", (e) => {
            e.preventDefault();
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const delta = e.deltaY > 0 ? -1 : 1;
            scale = Math.min(maxScale, Math.max(minScale, scale + delta * scaleStep));
            updateTransform();
        });
        cityHolder.addEventListener("pointerdown", (e) => {
            if (isDragging) return;
            isPanning = true;
            const rect = cityContainer.getBoundingClientRect();
            startPan = { x: e.clientX - worldX * cityRect.width, y: e.clientY - worldY * cityRect.height, worldX: worldX, worldY: e.clientY };
            console.log('startPan', startPan,)
            cityHolder.classList.add("grabbing");
        });

        cityHolder.addEventListener("pointermove", (e) => {
            if (!isPanning) return;
            const rect = cityContainer.getBoundingClientRect();
            worldX = (e.clientX - startPan.x) / cityRect.width;
            worldY = (e.clientY - startPan.y) / cityRect.height;
            updateTransform();
        });

        cityHolder.addEventListener("pointerup", () => {
            isPanning = false;
            cityHolder.classList.remove("grabbing");
        });

        cityHolder.addEventListener("pointerleave", () => {
            isPanning = false;
            cityHolder.classList.remove("grabbing");
        });

        renderBuildings();
        updateTransform();
    </script>

</body>

</html>